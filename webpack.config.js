/* eslint-disable @typescript-eslint/no-var-requires, import/order */
const path = require("path");

const webpack = require("webpack");
const TerserPlugin = require("terser-webpack-plugin");
const ForkTsCheckerWebpackPlugin = require("fork-ts-checker-webpack-plugin");
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const HtmlWebpackPlugin = require("html-webpack-plugin");

const assertEnv = (env) => {
  if (env !== "production" && env !== "development") {
    throw new Error(
      `invalid env: ${env}, should "webpack --env production" or "webpack --env development"`
    );
  }

  if (env !== process.env.NODE_ENV) {
    throw new Error(
      `env and process.env.NODE_ENV did not match. env: ${env} process.env.NODE_ENV: ${process.env.NODE_ENV}`
    );
  }
};

const isProductionEnv = (env) => env === "production";

/**
 * @type import("webpack").ConfigurationFactory
 */
module.exports = (env, _argv) => {
  assertEnv(env);

  const isProduction = isProductionEnv(env);
  const isDevelopment = !isProduction;
  const webpackMode = isProduction ? "production" : "development";

  const outputPath = path.resolve(__dirname, "dist/");
  const publicPath = "/";
  const tsConfigFile = "tsconfig.json";

  const babelLoader = { loader: "babel-loader" };
  const excludeRule = /(node_modules|bower_components)/;
  const enableEsModule = false;
  const sourceMap = isDevelopment ? "source-map" : false;

  /**
   * @param {webpack.Configuration} webpackConfig
   * @returns {webpack.Configuration}
   */
  const mergeWebpackConfig = (webpackConfig) => {
    if (isProduction) {
      return webpackConfig;
    } else {
      return {
        ...webpackConfig,
        devServer: {
          contentBase: outputPath,
          port: 8080,
          publicPath: publicPath,
          index: "index.html",
          hot: true,
          hotOnly: true,
          overlay: true,
        },
      };
    }
  };

  /** @type {webpack.Configuration} */
  const webpackBaseConfig = {
    mode: webpackMode,
    target: "web",
    entry: {
      index: "./src/index.tsx",
    },
    output: {
      path: outputPath,
      publicPath: publicPath,
      filename: "js/[name].[hash].js",
      chunkFilename: "js/[id].[hash].js",
    },
    resolve: {
      extensions: [".ts", ".tsx", ".js", ".jsx"],
      modules: ["node_modules"],
    },
    module: {
      rules: [
        {
          test: /\.jsx?$/,
          exclude: excludeRule,
          use: [babelLoader],
        },
        {
          test: /\.tsx?$/,
          exclude: excludeRule,
          use: [babelLoader],
        },
        {
          test: /\.css$/,
          exclude: excludeRule,
          use: [
            {
              loader: MiniCssExtractPlugin.loader,
              options: {
                publicPath: publicPath,
                esModule: enableEsModule,
                hmr: isDevelopment,
                // if hmr does not work, this is a forceful method.
                reloadAll: true,
              },
            },
            {
              loader: "css-loader",
              options: {
                url: true,
                import: true,
                sourceMap: isDevelopment,
                importLoaders: 2,
                esModule: enableEsModule,
                modules: {
                  mode: "local",
                  exportLocalsConvention: "asIs",
                  exportOnlyLocals: false,
                },
              },
            },
            {
              loader: "resolve-url-loader",
              options: {
                sourceMap: isDevelopment,
                removeCR: false,
                debug: isDevelopment,
                root: false,
              },
            },
            {
              loader: "postcss-loader",
              options: {
                // NOTE: Must sourceMap: true
                // resolve-url-loader 3.x depends on sourceMap generated by the previous loader.
                sourceMap: true,
                postcssOptions: {
                  config: path.resolve(__dirname, "postcss.config.js"),
                },
              },
            },
          ],
        },
        {
          test: /\.(woff|woff2|eot|ttf|svg)$/,
          // NOTE: Don't exclude node_modules directory because get font files
          // from node_modules/fontsource-roboto directory.
          //
          // exclude: excludeRule,
          use: [
            {
              loader: "file-loader",
              options: {
                name: "[name].[ext]",
                outputPath: "font",
                publicPath: path.posix.join(publicPath, "font"),
                emitFile: true,
              },
            },
          ],
        },
      ],
    },
    plugins: [
      new ForkTsCheckerWebpackPlugin({
        typescript: {
          configFile: tsConfigFile,
          mode: "write-tsbuildinfo",
          diagnosticOptions: {
            semantic: true,
            syntactic: true,
          },
        },
      }),
      new HtmlWebpackPlugin({
        chunks: ["index"],
        templateContent: `
      <html>
        <head>
        </head>
        <body>
          <div id="root"></div>
        </body>
      </html>`,
        filename: "index.html",
        inject: true,
        title: "Material-UI playground",
        meta: {
          // Material-UI viewport.
          // https://material-ui.com/getting-started/usage/#responsive-meta-tag
          viewport: "minimum-scale=1, initial-scale=1, width=device-width",
          charset: "UTF-8",
        },
        scriptLoading: "blocking",
        base: false,
        xhtml: false,
      }),
      new MiniCssExtractPlugin({
        filename: "css/[name].[hash].css",
        chunkFilename: "css/[id].[hash].css",
        ignoreOrder: false,
      }),
    ],
    optimization: {
      // Auto set process.env.NODE_ENV in webpack build environment.
      nodeEnv: webpackMode,
      minimize: isProduction,
      minimizer: [
        new TerserPlugin({
          test: /\.m?js(\?.*)?$/i,
          extractComments: false,
          terserOptions: {
            sourceMap: isDevelopment,
            compress: {
              ecma: 5,
              warnings: true,
              comparisons: false,
              // Don't use `inline: 2`.
              // https://github.com/terser-js/terser/issues/120
              inline: 2,
              dead_code: true,
              drop_debugger: true,
              keep_classnames: false,
              keep_fargs: true,
              keep_infinity: false,
              keep_fnames: false,
            },
            mangle: {
              safari10: true,
            },
            keep_classnames: false,
            keep_fnames: false,
            output: {
              ecma: 5,
              ascii_only: true,
              comments: /^\**!|@preserve|@license|@cc_on/i,
            },
          },
        }),
      ],
    },
    devtool: sourceMap,
  };

  return mergeWebpackConfig(webpackBaseConfig);
};
