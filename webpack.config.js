/* eslint-disable @typescript-eslint/no-var-requires, import/order */
const path = require("path");

const webpack = require("webpack");
const TerserPlugin = require("terser-webpack-plugin");
const ForkTsCheckerWebpackPlugin = require("fork-ts-checker-webpack-plugin");
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const HtmlWebpackPlugin = require("html-webpack-plugin");

const argvEnvironments = ["production", "development"];
const assertEnv = (env) => {
  const envCount = Object.keys(env).filter((key) =>
    argvEnvironments.includes(key)
  ).length;

  if (envCount !== 1) {
    throw new Error(
      `invalid --env option: must specify build environment option, one of "webpack --env production" or "webpack --env development"`
    );
  }

  if (!env[process.env.NODE_ENV]) {
    throw new Error(
      `env and process.env.NODE_ENV did not match. process.env.NODE_ENV: ${process.env.NODE_ENV}`
    );
  }
};

const isProductionEnv = (env) => Boolean(env.production);

/**
 * @type import("webpack").ConfigurationFactory
 */
module.exports = (env, _argv) => {
  assertEnv(env);

  const isProduction = isProductionEnv(env);
  const isDevelopment = !isProduction;
  const webpackMode = isProduction ? "production" : "development";

  const outputPath = path.resolve(__dirname, "dist/");
  const publicPath = "/";
  const tsConfigFile = "tsconfig.json";

  const babelLoader = { loader: "babel-loader" };
  const sourceRoot = path.resolve(__dirname, "src/");
  const enableEsModule = false;
  const sourceMap = isDevelopment ? "source-map" : false;

  /**
   * @param {webpack.Configuration} webpackConfig
   * @returns {webpack.Configuration}
   */
  const mergeWebpackConfig = (webpackConfig) => {
    if (isProduction) {
      return webpackConfig;
    } else {
      // NOTE: devServer.publicPath always starts and ends with a forward slash.
      const devServerPublicPath = path.posix.join("/", publicPath, "./");

      return {
        ...webpackConfig,
        devServer: {
          contentBase: false,
          port: 8080,
          publicPath: devServerPublicPath,
          index: "index.html",
          // Fall back on all react-router routing path patterns that use BrowserHistory.
          historyApiFallback: {
            rewrites: [
              {
                from: /^\/.*/,
                to: devServerPublicPath,
              },
            ],
          },
          hot: true,
          hotOnly: true,
          overlay: true,
        },
      };
    }
  };

  /** @type {webpack.Configuration} */
  const webpackBaseConfig = {
    mode: webpackMode,
    target: "web",
    entry: {
      index: "./src/index.tsx",
    },
    output: {
      path: outputPath,
      publicPath: publicPath,
      filename: "js/[name].[contenthash].js",
      chunkFilename: "js/[id].[contenthash].js",
      assetModuleFilename: "images/[name][contenthash][ext][query]",
    },
    resolve: {
      extensions: [".ts", ".tsx", ".js", ".jsx"],
      modules: ["node_modules"],
    },
    module: {
      rules: [
        {
          test: /\.jsx?$/,
          include: [sourceRoot],
          use: [babelLoader],
        },
        {
          test: /\.tsx?$/,
          include: [sourceRoot],
          use: [babelLoader],
        },
        {
          test: /\.css$/,
          include: [sourceRoot],
          use: [
            {
              loader: MiniCssExtractPlugin.loader,
              options: {
                publicPath: publicPath,
                esModule: enableEsModule,
                hmr: isDevelopment,
                // if hmr does not work, this is a forceful method.
                reloadAll: true,
              },
            },
            {
              loader: "css-loader",
              options: {
                url: true,
                import: true,
                sourceMap: isDevelopment,
                importLoaders: 2,
                esModule: enableEsModule,
                modules: {
                  mode: "local",
                  exportLocalsConvention: "asIs",
                  exportOnlyLocals: false,
                },
              },
            },
            {
              loader: "resolve-url-loader",
              options: {
                sourceMap: isDevelopment,
                removeCR: false,
                debug: isDevelopment,
                root: false,
              },
            },
            {
              loader: "postcss-loader",
              options: {
                // NOTE: Must sourceMap: true
                // resolve-url-loader 3.x depends on sourceMap generated by the previous loader.
                sourceMap: true,
                postcssOptions: {
                  config: path.resolve(__dirname, "postcss.config.js"),
                },
              },
            },
          ],
        },
        {
          test: /\.(woff|woff2|eot|ttf|svg)$/,
          type: "asset/resource",
          generator: {
            filename: "font/[name][contenthash][ext][query]",
          },
          // NOTE: Include node_modules/fontsource-roboto directory to bundle Roboto-font.
          include: [path.resolve(__dirname, "node_modules/fontsource-roboto")],
        },
      ],
    },
    plugins: [
      new ForkTsCheckerWebpackPlugin({
        typescript: {
          configFile: tsConfigFile,
          mode: "write-tsbuildinfo",
          diagnosticOptions: {
            semantic: true,
            syntactic: true,
          },
        },
      }),
      new HtmlWebpackPlugin({
        chunks: ["index"],
        templateContent: `
      <html>
        <head>
        </head>
        <body>
          <div id="root"></div>
        </body>
      </html>`,
        filename: "index.html",
        inject: true,
        title: "Material-UI playground",
        meta: {
          // Material-UI viewport.
          // https://material-ui.com/getting-started/usage/#responsive-meta-tag
          viewport: "minimum-scale=1, initial-scale=1, width=device-width",
          charset: "UTF-8",
        },
        scriptLoading: "blocking",
        base: false,
        xhtml: false,
      }),
      new MiniCssExtractPlugin({
        filename: "css/[name].[contenthash].css",
        chunkFilename: "css/[id].[contenthash].css",
        ignoreOrder: false,
      }),
    ],
    optimization: {
      // Auto set process.env.NODE_ENV in webpack build environment.
      nodeEnv: webpackMode,
      minimize: isProduction,
      minimizer: [
        new TerserPlugin({
          test: /\.m?js(\?.*)?$/i,
          extractComments: false,
          terserOptions: {
            sourceMap: isDevelopment,
            compress: {
              ecma: 5,
              warnings: true,
              comparisons: false,
              // Don't use `inline: 2`.
              // https://github.com/terser-js/terser/issues/120
              inline: 2,
              dead_code: true,
              drop_debugger: true,
              keep_classnames: false,
              keep_fargs: true,
              keep_infinity: false,
              keep_fnames: false,
            },
            mangle: {
              safari10: true,
            },
            keep_classnames: false,
            keep_fnames: false,
            output: {
              ecma: 5,
              ascii_only: true,
              comments: /^\**!|@preserve|@license|@cc_on/i,
            },
          },
        }),
      ],
    },
    devtool: sourceMap,
  };

  return mergeWebpackConfig(webpackBaseConfig);
};
